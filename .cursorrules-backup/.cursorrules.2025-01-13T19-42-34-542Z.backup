{
    "version": "1.0.0",
    "languages": {
        "default": {
            "rules": [
                {
                    "id": "rule-1",
                    "level": "error",
                    "description": "/ Dynamic .cursorrules Analyzer - VSCode Extension\n// Author: Garot Conklin (garotm)\n\n// What you can build with this ruleset:\nA TypeScript-based VSCode extension that:\n- Automatically analyzes project codebases for patterns and conventions\n- Generates and updates .cursorrules files based on detected patterns\n- Monitors file changes in real-time to suggest rule updates\n- Manages rule versioning and history\n- Integrates directly with VSCode\n- Implements intelligent rule merging and conflict resolution\n- Offers commands for manual rule generation and validation\n\n// Project Structure\nFollow this directory structure:\nsrc/\n  extension.ts         # Extension activation and setup\n  languageDetector.ts  # Language detection logic\n  test/               # Test files\n    runTest/          # Test runner setup\n    suite/            # Test suites\n  types/             # Type definitions\n\n// Development Guidelines\n1. Code Quality:\n   - Use TypeScript 5.x features\n   - Enable strict type checking\n   - Follow ESLint configuration\n   - Maximum line length: 100 characters\n   - Use Prettier for formatting\n   - Maintain clean code principles\n\n2. Testing Requirements:\n   - Maintain 90%+ test coverage\n   - Use Mocha test framework\n   - Mock VSCode API when needed\n   - Test both success and failure cases\n   - Include extension activation tests\n   - Document test scenarios\n\n3. Documentation Standards:\n   - Use TSDoc comments\n   - Document all public APIs\n   - Include usage examples\n   - Maintain up-to-date README\n   - Document extension settings\n\n4. Error Handling:\n   - Use typed errors\n   - Implement proper logging\n   - Handle VSCode lifecycle\n   - Handle edge cases\n   - Provide clear error messages\n\n5. Performance:\n   - Use efficient data structures\n   - Implement debouncing for file watchers\n   - Optimize extension activation\n   - Monitor memory usage\n   - Cache when appropriate\n\n// Code Examples:\n\n1. Class Definition Pattern:\n```typescript\nimport * as vscode from 'vscode';\nimport { Uri } from 'vscode';\n\nexport type Language = 'python' | 'typescript' | 'javascript' | 'unknown';\n\nexport class LanguageDetector {\n    private readonly extensionMap: Record<string, Language> = {\n        '.py': 'python',\n        '.ts': 'typescript',\n        '.js': 'javascript'\n    };\n\n    public detectLanguage(uri: Uri): Language {\n        const extension = path.extname(uri.fsPath).toLowerCase();\n        return this.extensionMap[extension] || 'unknown';\n    }\n}\n```\n\n2. Error Handling Pattern:\n```typescript\nclass RuleAnalysisError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'RuleAnalysisError';\n    }\n}\n\nasync function analyzeFile(uri: vscode.Uri): Promise<string[]> {\n    try {\n        // Analysis logic\n        return patterns;\n    } catch (error) {\n        throw new RuleAnalysisError(\n            `Failed to analyze ${uri.fsPath}: ${error.message}`\n        );\n    }\n}\n```\n\n3. Testing Pattern:\n```typescript\nimport * as assert from 'assert';\nimport * as vscode from 'vscode';\nimport { LanguageDetector } from '../../languageDetector';\n\nsuite('LanguageDetector Test Suite', () => {\n    let detector: LanguageDetector;\n\n    setup(() => {\n        detector = new LanguageDetector();\n    });\n\n    test('should detect TypeScript files', () => {\n        const uri = vscode.Uri.file('/path/to/test.ts');\n        assert.strictEqual(detector.detectLanguage(uri), 'typescript');\n    });\n});\n```\n\n// Best Practices:\n1. Use VSCode API types consistently\n2. Implement proper disposables\n3. Use async/await for asynchronous operations\n4. Register commands with clear names\n5. Follow VSCode extension guidelines\n6. Use workspace configuration\n7. Implement proper status bar updates\n8. Handle extension activation events\n9. Write clear commit messages\n10. Keep functions focused and small\n\n// Security Considerations:\n1. Validate all URIs\n2. Don't execute analyzed code\n3. Handle workspace trust\n4. Sanitize all inputs\n5. Use secure defaults\n6. Implement proper error handling\n7. Log security-relevant events\n8. Use safe file operations\n9. Validate configuration\n10. Handle sensitive data appropriately"
                }
            ]
        }
    }
}