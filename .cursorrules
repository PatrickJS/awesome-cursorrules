// Dynamic .cursorrules Analyzer - AI Development Guidelines
// Author: Garot Conklin (garotm)

// What you can build with this ruleset:
A Python-based dynamic analyzer for .cursorrules files that:
- Automatically analyzes project codebases for patterns and conventions
- Generates and updates .cursorrules files based on detected patterns
- Monitors file changes in real-time to suggest rule updates
- Manages rule versioning and history
- Provides an API for IDE integration
- Implements intelligent rule merging and conflict resolution
- Offers CLI tools for manual rule generation and validation

// Project Structure
Follow this directory structure:
src/
  cursor_rules_dynamic/
    __init__.py          # Package initialization and version
    analyzer.py          # Code analysis engine
    watcher.py          # File system monitoring
    rules_manager.py    # Rules management
    exceptions.py       # Custom exceptions
tests/
  __init__.py
  test_*.py            # Test files matching implementation
scripts/               # Development and utility scripts
docs/                 # Documentation

// Development Guidelines
1. Code Quality:
   - Use Python 3.8+ features
   - Implement strict type hints
   - Follow PEP 8 style guide
   - Maximum line length: 100 characters
   - Use black for formatting
   - Use isort for import sorting
   - Run pylint for linting

2. Testing Requirements:
   - Maintain 90%+ test coverage
   - Write pytest fixtures
   - Mock external dependencies
   - Test both success and failure cases
   - Include performance tests
   - Document test scenarios

3. Documentation Standards:
   - Use Google-style docstrings
   - Document all public APIs
   - Include usage examples
   - Maintain up-to-date README
   - Document configuration options

4. Error Handling:
   - Define custom exceptions
   - Use structured logging
   - Implement proper cleanup
   - Handle edge cases
   - Provide clear error messages

5. Performance:
   - Use efficient data structures
   - Implement debouncing
   - Optimize file operations
   - Monitor memory usage
   - Cache when appropriate

// Code Examples:

1. Class Definition Pattern:
```python
from pathlib import Path
from typing import Dict, List, Optional

class CodeAnalyzer:
    """Analyzes project code for patterns and conventions.

    Args:
        project_root: Root directory of the project to analyze.
        config: Optional configuration dictionary.

    Attributes:
        patterns: Dictionary of detected code patterns.
    """

    def __init__(self, project_root: Path, config: Optional[Dict] = None) -> None:
        self.project_root = project_root
        self.patterns: Dict[str, List[str]] = {}
        self._configure(config or {})
```

2. Error Handling Pattern:
```python
class RuleAnalysisError(Exception):
    """Raised when rule analysis fails."""
    pass

def analyze_file(self, file_path: Path) -> List[str]:
    """Analyze a file for patterns.
    
    Args:
        file_path: Path to the file to analyze.
        
    Returns:
        List of detected patterns.
        
    Raises:
        RuleAnalysisError: If analysis fails.
    """
    try:
        # Analysis logic
        return patterns
    except Exception as e:
        raise RuleAnalysisError(f"Failed to analyze {file_path}: {str(e)}")
```

3. Testing Pattern:
```python
import pytest
from pathlib import Path

@pytest.fixture
def analyzer():
    """Create a CodeAnalyzer instance for testing."""
    return CodeAnalyzer(Path("."))

def test_pattern_detection(analyzer, tmp_path):
    """Test pattern detection in Python files."""
    test_file = tmp_path / "test.py"
    test_file.write_text("class TestClass:\n    pass")
    
    patterns = analyzer.analyze_file(test_file)
    assert patterns  # Verify patterns were detected
```

// Best Practices:
1. Use Path objects for file operations
2. Implement context managers for resource handling
3. Use dataclasses for data containers
4. Implement proper cleanup in destructors
5. Follow the observer pattern for file watching
6. Use environment variables for configuration
7. Implement proper logging at all levels
8. Use type hints consistently
9. Write clear, descriptive commit messages
10. Keep functions focused and small

// Security Considerations:
1. Validate all file paths
2. Don't execute analyzed code
3. Handle permissions carefully
4. Sanitize all inputs
5. Use secure defaults
6. Implement proper error handling
7. Log security-relevant events
8. Use safe file operations
9. Validate configuration
10. Handle sensitive data appropriately